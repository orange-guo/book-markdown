[toc]
# 2 重构



## 2.1 何谓重构
### 定义
- 一种保持行为的转换
- 一种对软件内部结构的改善, 在不影响软件的可见行为情况下，使其容易理解修改，修改成本更低
### 重构过程
- 去除重复
- 简化复杂逻辑
- 澄清模糊代码
- 修改命名，增强其可读性
- 合并提供公共功能相关的类， 增强其内聚性
- ...
### 保证重构安全性(确保所做的修改不会产生任何破坏)
> 使用手工测试或者运行自动化测试 
### 自动化测试对重构的好处
> 若能快速地运行自动化测试， 确保修改后的代码仍能够工作, 则可以放心重构并且能够尝试实验性的设计， 因为有自动化测试代码帮助快速反馈错误



## 2.2 重构的动机(为什么要重构)
### 更容易增加新代码
良好的设计让系统加入新的功能更快,而为了快速开发实现的系统将随着时间的流逝以及功能的变多导致加入新的功能越来越难
### 改善既有代码的设计
持续重构不断地嗅探代码的坏味道, 一旦发现就立即去除, 代码的扩展和维护将更加容易
### 增强对代码的理解
通过对不理解的代码或设计有问题的代码进行重构, 再重构的过程加深对设计的理解
### 提高编程的趣味性
重构之后对系统的可维护性增强, 代码集成的时间也将缩短, 并且编程体验也会改善



## 2.3 要得到最佳的重构结果需要多人的帮助(这正是极限编程和代码集体所有这两种时间的原因)



## 2.4 可读性好的代码
### 通过重构增强代码的可读性
> 任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。[F,15]



## 2.5 保持代码清晰可见
> 要保持代码清晰，必须持续地去除重复，简化和澄清代码。决不能容忍代码中的脏乱，决不能倒退到坏习惯中去。清晰的代码能产生更好的设计，而更好的设计将使开发过程更加迅速，从而会使客户和程序员皆大欢喜。



## 2.6 循序渐进进行重构
> 我们许多人都有类似的经历——跨越的步子太大，然后奋战几分钟、几小时甚至几个日夜，以重得绿条。我对重构的理解愈深，就愈倾向于采取小而安全的步骤。事实上，绿条就像一个陀螺仪，能够使我不偏离航线。如果红条显示的时间太长——超过几分钟，我就知道自己采取的步骤不够小。然后我会返工，重新开始。我几乎总是发现，采取更小、更安全的步骤比采取更大的步骤更能快速达到目标。



## 2.7 减少设计欠账(改善设计)
> 由于忽视了或者有意地“没有坏就不修改”，许多程序员和开发团队很少花时间偿还设计欠账。结果，他们开发出来的程序就成了大泥球（Big Ball of Mud）[Foote and Yoder]。用金融术语来说，如果不偿还债务，就会产生滞纳金。如果不偿还滞纳金，滞纳金就会越积越多。未偿还的金额越大，滞纳金和要付的钱就越多。这可是按复利计算的，而且随着时间推移，还清这些欠账就变成不可实现的梦。设计欠账也是如此。

> 在谈起设计欠账时，我经常拿出一张信用卡，给经理们看。我问他们：“你们会连续多少个月不付清欠账呢？”虽然有人并不是每月都还清欠账，但是几乎所有人都不会让欠账累积太长时间。这样的讨论很容易使经理们认识到，一直持续地还清设计欠账实乃明智之举。



## 2.8 通过重构持续演变出新的架构
> 演进式设计提供了更好的方式。它建议：
成立一个小组；
用应用需求驱动框架；
通过重构，持续改进应用程序和框架。
重构是其中不可缺少的因素。正是重构，使小组能够高效且有效地演变出一个全新的架构。



## 2.9 复合重构&测试驱动的重构
### 复合重构定义
复合重构 （composite refactoring）就是由多个低层次重构组成的高层次重构。低层次重构所完成的许多工作都涉及代码的搬移。
`例如，提炼函数[F]重构需要将代码搬移到一个新函数中，函数上移[F]重构需要将方法从子类搬移到超类，提炼类[F]重构需要将代码搬移到新类中，而搬移函数[F]重构需要将函数从一个类搬移到另一个类。`
### 测试
它可以用来重新编写、代替老代码。测试驱动的重构 （test-driven refactoring）包括应用测试驱动开发得到替换代码，然后将老代码替换为新代码（同时保留并重新运行老代码的测试）。
`例如可以先编写好新算法，用它替换老算法，然后看测试能否通过。如果测试无法通过，你很可能要花上很长时间进行调试。编写算法的更好方式是使用测试驱动开发。这种方式能够产生简单的代码，而且还能产生测试，从而使你或者其他人能够在此后充满自信地应用各种低层次重构或者复合重构。`
### 总结
> `与测试驱动的重构相比，复合重构的使用率要高得多，因为大量重构工作只是改变原有代码的位置。当这样无法改善设计时，采用测试驱动的重构能够帮助我们安全而且有效地得到更佳的设计。`
> `在实际重构中，可能大多数时间都在使用低层次重构和复合重构。只需要记住，通过测试驱动的重构完成的“重新实现和替换”技术，也是重构的一种有用方式即可。在设计一种新的算法或者机制时这种方式最有效，而且这种方式比应用低层次重构或者复合重构更容易。`



# 2.10 复合重构的优点
> 复合重构引导你从源头走到目的地。由于源头的差异，这个目的地可能很明显，也可能不太明显。这很大程度上取决于你对模式的熟悉程度，每个模式都定义一个目的地以及各种影响因素，这些因素提示你需要趋向或者到达那个目的地。