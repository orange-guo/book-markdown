[toc]
# 代码坏味道



## 0.前言
> 当你学会用挑剔的眼光审视自己所写的文字时，会发现将一段文字反复读上五六遍，每次都会找到新的问题。[Barzun,229]
> 重构，是对既有代码设计的改善，要求重构者需要知道什么样的代码需要改善， 重构目录可以获取这些知识，但是实际情况可能与目录中看得到不同
#### 最常见的设计问题
- 代码重复
- 代码不清晰
- 代码过于复杂
#### 《重构》中关于代码坏味道的指导
> 1. 在《重构》第3章“代码的坏味道”
> 2. Fowler和Beck的代码坏味针对的是出现在各种地方的问题：方法中、类中、类层次中、包（名字空间、模块）中和整个系统中。他们为坏味起的名字，例如依恋情结（Feature Envy）、基本类型偏执（Primitive Obsession）和夸夸其谈未来性（Speculative Generality），为程序员提供了丰富多彩的词汇，使用这些词汇能够更加快捷地探讨设计问题。



## 1. 重复代码(Duplicated Code)
- 模板方法 (去除类层次中不同子类里存在的明显和/或微妙的重复)
- 工厂方法 (如果不同子类的创建逻辑不同但是其他实现方式都类似)
- 应用链构造函数 (如果类有多个构造方法并且包含重复代码)
- Composite (如果有单独的代码处理一个对象或者一组对象)
- Adapter (如果对象处理方式的区别仅在于它们的接口不同)
- Null Object (如果有条件逻辑用于处理空对象，而且相同的空逻辑在整个系统中都是重复的)



## 2. 过长函数(Long Method)
#### 函数短胜于长的理由
- 两个很长的函数可能包含重复代码, 如果将这些函数分解为小函数就能抽出其中的一些通用逻辑并复用
- 小的函数能够帮助理解代码
#### 函数多小合适?
- 最好10行以内
#### 小函数的一连串调用性能上的问题
- 许多小的函数调用串起来性能开销微乎其微
- 即使因此遇见性能问题, 可以通过重构改进性能, 无需放弃小方法原则化
#### 长函数重构方式
> 应用组合方法重构将它分解为一个Composed Method, 通常要用到提炼函数
- 使用`Collecting Parameter`来解决当转换为`Composed Method`的代码要将某个信息累加到一个公共变量中的情况
- 使用`Command`来解决当分派和处理请求的大的switch语句的情况, 从而缩短函数长度(替换条件调度程序)
- 使用`Visitor`来解决出现当使用switch语句从接口不同的类收集数据的情况



## 3. 条件逻辑复杂(Conditional Complexity)
> 有的时候当实现几个新功能后, 原本容易理解的条件逻辑可能会突然变得复杂并且开销高昂
#### 解决方案
- 使用`Strategy`解决当条件逻辑控制的是几种计算操作中的某一个的情况
- 使用`Decorator`解决当条件逻辑控制的是应该执行类核心行为之外某个特殊行为之外某个特殊行为的若干段的某一段的情况
- 使用`State`解决当控制对象状态转换的条件比较复杂的情况
- 使用`Null Object`解决当系统中出现很多重复的相同的空处理逻辑



## 4. 基本类型偏执(Primitive Obsession)
#### 基本类型具有一般性
基本类型例如整型字符串等等语言中基本的类型具有一般性, 因为有很多人要去使用他们, 类是非常特定的因为创建他们就是用于特定的目的
#### 代码过于依赖基本类型的原因
> 这通常出现在没有看到如何用更高层的抽象澄清或者简化代码的时候。
#### 基本类型不安全的原因
使用类替换类型代码, 当基本类型控制着类中的逻辑, 并且客户端可以赋给它不安全的值
#### 解决方法
- `State`(控制对象的状态转换的是使用基本类型值的复杂条件逻辑)
- `Strategy`(控制算法运行的是非常复杂的条件逻辑，而且该逻辑还使用基本类型值)
- `Composite`(当隐式创建了使用基本类型表示的树结构, 比如字符串,代码将非常难用,易错而且充满重复)
- `Interpreter`(类有许多方法支持多个基本类型值的组合，那么就可能存在隐式语言)
- `Decorator`(基本类型值只是为提供类的核心职责的装饰)
#### 解决方法总结
> 即使有类，但是它过于原始，对客户代码的用处不大。比如，很难使用的 Composite[DP]实现。可以通过应用用Builder封装Composite（6.5节）重构简化客户构建 Composite 的工作。



## 5. 不恰当的暴露(Indecent Exposure)
#### 信息隐藏原则(David Parnas)
服务者应该隐藏客户代码不应该看到的方法或者类
#### 坏处
意味着客户了解到不太重要或者只有间接重要性的代码, 这会增加代码的复杂程度
#### 解决方案
- 使用Factory解决屏蔽创建细节(构造函数)以及屏蔽类具体细节
(通过Factory)返回类公共接口,客户端只依赖接口和Factory



## 6. 解决方案蔓延(Solution Sprawl)
#### 定义
当许多类中都有用来完成某些职责的代码和/或数据
#### 出现的情况
通常是由于在系统中快速添加特性, 却没有花费足够时间来简化和改进设计以适应新特性而造成的
#### 散弹式修改
在添加或者更新系统特性，并需要对许多不同的代码段进行修改
#### 解决方案蔓延和散弹式修改的区别(孪生兄弟)
发现方法不同而已。前者通过观察发觉，后者需要在实践中察觉。
#### 将创建知识搬移到Factory重构解决对象创建职责蔓延问题



## 7. 异曲同工的类(Alternative Classes with Different Interfaces)
> 两个相似类却有不同接口的时候。如果发现两个类很相似，通常可以将它们重构为共享一个公共的接口。
使用Adapter统一接口重构, 为两个类生成一个公共接口。例如第三方库有相似地方



## 8. 冗赘类(Lazy Class)
> 类如果功能有限，缺乏存在价值，就应该删除. 经常能够遇到缺乏存在价值的Singleton. 事实上，Singleton可能使你的设计过分依赖全局数据，致使代价过高。使用内联重构快速而优雅地删除Singleton


## 9. 结构过于大的类(Large Class)
> 一般而言，过大的类通常包含过多的职责。
提炼类[F]和提炼子类[F]重构是用来处理这种坏味的主要重构，有助于将职责搬移到其他类中。本书中模式导向的重构都将使用这种重构为类减肥。



## 10. 分支语句(Switch Statement)
- 用Command替换条件调度程序, 每个Command对象都可以不使用条件逻辑进行查找和调用。
- Visitor解决当分支语句保存来自具有不同接口的实例的数据。通过将这段代码重构为使用Visitor[DP]，就不需要使用条件逻辑，而且设计也变得更加灵活。



## 11. 组合爆炸(Combinatorial Explosion)
#### 解释
> 这种坏味其实是一种不那么明显的重复。当有许多段代码使用不同种类或数量的数据或对象做同样的事情时，就会出现这种坏味。
#### 案例&解决方案
> 假设类中每个方法都使用特定的条件和数据执行查询。需要支持的特殊查询越多，查询方法也就越多。处理各种查询方式的方法就会大爆炸。此外，你还使用隐式的查询语言。
> 应用用 Interpreter 替换隐式语言，可以删除所有这些方法



## 12. 怪异解决方案
#### 定义
> 在系统中应该始终用一种方式解决一种问题，反正就称之为怪异或者不一致的解决方案。这种坏味的出现往往说明存在不易察觉的重复代码。
#### 如何去除
要去除这种重复，首先应该确定应该采用哪一种解决方案。在某些情况下，使用率最低的方案可能是优先方案，如果它确实优于大多数时候使用的方案。在确定优先方案后，通常可以应用替换算法[F]重构得到贯穿系统始终的一致方案。给定一致方案后，就可以将解决方案的所有实例都搬移到一处，从而去除重复。
#### 解决案例
有一种优先方式与一组类通信，而由于类的接口不同，无法以一致的方式与它们通信。通过Adapter统一接口，生成一个公共接口，用它来一致地与所有类通信。


