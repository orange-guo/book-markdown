在之前创建一个类对外提供对象实例的方法是提供一个构造方法, 还有另一种方式, 那就是提供一个公共的静态方法, 这个方法只是用于返回其所在类的实例, 下面是一个`Boolean`类的一个简单的例子(`Boolean`基本类型的包装类)。 

```
// 此方法将`boolean`基本类型转换为`Boolean`对象引用
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```
从上面的代码片段可以看到, 对外提供一个用于创建本类实例的静态方法,  在方法内部创建实例, 这样可以让调用者无需知道类的创建细节, 只需调用方法即可, 当然, 使用静态方法构建实例并不是十全十美的, 既有优点, 同时也有缺点
##优点
>1.静态工厂方法更能直观的描述创建对象, 方便阅读

因为在Java中构造方法必须跟类名一致, 也就导致了这个构造方法并不能很好地描述被返回的对象，但是使用静态工厂方法本身可以命名更易于使用, 可以更容易直观描述被创建的对象。 
例如，`User`类有一个`newUserWithGenderMale()`的静态工厂方法用于返回性别为男的`User`对象, 如果是比较复杂的对象,使用静态工厂方法生成的方法可以使调用者更容易阅读

>2.不必每次调用时都创建对象,节省内存开销, 类似于Flyweight(享元)设计模式

使用构造方法会每次创建都会返回一个对象, 如果在构造比较重量级的对象的话, 每次构造的成本比较大。
如果使用静态工厂的话, 如果该类有复用的需求的话, 可以将这个类缓存起来, 便于下一次使用, 更节省内存。
例如, `Boolean.valueof(boolean)`方法说明了这种方法：它从不创建对象。
同时,它允许一个不可变的值类保证不存在两个相同的实例：当且仅当`a == b`时`a.equals(b)`。

>3.它可以返回其返回类型的任何子类对象, 因为构造方法在调用时就确定了类型

在Java 8之前，接口不能有静态方法。根据约定，一个名为`Type`的接口的静态工厂方法被放入一个非实例化的伙伴类(companion class)`Types`类中。例如，Java集合框架有45个接口的实用工具实现，提供不可修改的集合、同步集合等等。
几乎所有这些实现都是通过静态工厂方法在一个非实例类(`java.util.Collections`)中导出的。返回对象的类都是非公开的。
Collections框架API的规模要比它之前输出的45个单独的公共类要小得多，每个类有个便利类的实现。不仅是API的大部分减少了，还包括概念上的权重：程序员必须掌握的概念的数量和难度，才能使用API。
从Java 8开始，接口不能包含静态方法的限制被取消了，所以通常没有理由为接口提供一个不可实例化的伴随类。 很多公开的静态成员应该放在这个接口本身。 但是，请注意，将这些静态方法的大部分实现代码放在单独的包私有类中仍然是必要的。 这是因为Java 8要求所有接口的静态成员都是公共的。 Java 9允许私有静态方法，但静态字段和静态成员类仍然需要公开。


>4.可以根据传入参数的不同而返回不同实例

`EnumSet`类没有公共构造方法，只有静态工厂。 在OpenJDK实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：如果大多数枚举类型具有64个或更少的元素，静态工厂将返回一个`RegularEnumSet`实例， 返回一个`long`类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个`JumboEnumSet`实例，返回一个`long`类型的数组。
这两个实现类的存在对于客户是不可见的。 如果`RegularEnumSet`不再为小枚举类型提供性能优势，则可以在未来版本中将其淘汰，而不会产生任何不良影响。 同样，未来的版本可能会添加`EnumSet`的第三个或第四个实现，如果它证明有利于性能。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只关心它是`EnumSet`的一些子类。

>5.构成基于接口的框架

JDBC中, Java对数据库厂商提供了一些数据库操作接口例如`Connection`, `Driver`, `Statement`。
而数据库厂商只需要实现这些接口就可以完成对其数据库的操作。
这样设计的好处是用户只需要知道其接口方法用来干什么的, 并不需要关注其内部原理和实现细节, 在需要对应的数据库厂商的Driver时加载对应的`Driver`类。
例如以前在JDBC中注册MySQL的`Driver`只需要通过`Class.forName("com.mysql.jdbc.Driver")`, 注册对应的Driver类,  而在这个类被加载的时候会触发静态代码块如下
```
static {
    try {
        DriverManager.registerDriver(new Driver());
    } catch (SQLException var1) {
        throw new RuntimeException("Can't register driver!");
    }
}
```
`DriverManager.registerDriver(new Driver());`这个方法是Java对于各个数据库厂商提供的注册其Driver的方法, 用来注册到DriverManager中
同样`DriverManager.getConnection()`提供了获取`Connection`对象的方法
在客户端整个jdbc操作中, 例如`getConnection();`, `registerDriver(driver);`等方法全部都是针对接口的操作, 

##缺点
>1.没有公共或受保护构造方法的类不能被子类化

>2.很难找到这些工厂方法

##静态工厂方法的常用名称

| 方法名 | 说明 | 示例 |
| :-: | :-: | :-: |
|`from`| 类型转换方法，它接受单个参数并返回此类型的相应实例 | `  Date d = Date.from(instant)` |
| `of` | 一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起 | `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING)` |
| `valueOf` | from和to更为详细的替代方式 | `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)` |
| `instance  getInstance` | 返回一个由其参数(如果有的话)描述的实例，但不能说它具有相同的值 | `StackWalker luke = StackWalker.getInstance(options)` |
| `create newInstance` | 与`instance`或`getInstance`有些类似，除了该方法保证每个调用返回一个新的实 | `Object newArray = Array.newInstance(classObject, arrayLen)` |
| `getType` | 与`getInstance`类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型 | `FileStore fs = Files.getFileStore(path)` |
| `newType` | 与`newInstance`类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型 | `BufferedReader br = Files.newBufferedReader(path)` |
| `type` | `getType` 和 `newType`简洁的替代方式 | `List<Complaint> litany = Collections.list(legacyLitany)` |

##方法命名规则总结
>1.通过类型转换获取实例:
`from`, `valueOf`, 而`of`是将多个对象聚合成一个
>2.通过参数获取实例: 
`instance`, `getInstance`, `getType`(返回可复用实例)
`create`, `newInstance`, `newType`, `Type`(每次调用返回新实例)
>######注意`Type`, 表示一种类型
>例如`User`, 对应的方法就是`newUser()`, `getUser()`, `user()`
#总结
>总之，静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下提供公共构造方法。