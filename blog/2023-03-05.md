---
authors: [xiangcheng.kuo]
tags: [problem-solving, spring-boot, spring, ]
---

# 升级`springboot3`遇到的问题

本文主要整理了在升级`springboot3`的过程中遇到的问题.

<!--truncate-->

## querydsl依赖变更

将`querydsl`相关依赖的`classfiier`设置为`jakarta`.

```kotlin title="build.kts"
implementation("com.querydsl:querydsl-jpa:5.0.0:jakarta")
kapt("com.querydsl:querydsl-apt:5.0.0:jakarta")
```

### 参考

- [Are there plans to support SpringBoot3.0(Java17)?](https://github.com/querydsl/querydsl/issues/3296)

## 升级`spring-boot3`后代码中的`javax`包需要切换为`jakarta`

`springboot3`的`javax`依赖变为了`jakarta`, 代码中需要将包导入从`javax`切换到`jakarta`.

## 升级`spring-boot3`后访问由`@PreAuthorize`注解保护的接口报错

升级`spring-boot3`后访问由`@PreAuthorize`注解保护的接口报错, 报错为401

### 原因

`RoleHierarchy`失效, 导致`MGMT_SUPER_ADMIN`无法访问`@PreAuthorize("hasRole("MGMT_ADMIN")")`注解保护的接口。<br/>
因为`MGMT_SUPER_ADMIN`继承自`MGMT_ADMIN`。<br/>
这个问题的原因是由`@EnableGlobalMethodSecurity`到`@EnableMethodSecurity`的迁移导致。<br/>
这两者内部对于`defaultMethodExpressionHandler`的初始化行为不一致导致`RoleHierarchy`失效。<br/>
区别如下

- `@EnableGlobalMethodSecurity`
  <br/>实现类`GlobalMethodSecurityConfiguration`创建`defaultMethodExpressionHandler`时会尝试从容器中获取`RoleHierarchy`。
- `@EnableMethodSecurity`
  <br/>实现类`PrePostMethodSecurityConfiguration`创建`defaultMethodExpressionHandler`时不会从容器中获取`RoleHierarchy`。

### 解决方案

- 为`spring-security`创建`pull request`确保初始化`defaultMethodExpressionHandler`行为保持一致
- 对于自身项目当前的解决办法是初始化`MethodExpressionHandler`

### 备注

```java title="GlobalMethodSecurityConfiguration.java"
public class GlobalMethodSecurityConfiguration implements ImportAware, SmartInitializingSingleton, BeanFactoryAware {

	@Override
	public void afterSingletonsInstantiated() {
		try {
			initializeMethodSecurityInterceptor();
		} catch (Exception ex) {
			throw new RuntimeException(ex);
		}
		PermissionEvaluator permissionEvaluator = getSingleBeanOrNull(PermissionEvaluator.class);
		if (permissionEvaluator != null) {
			this.defaultMethodExpressionHandler.setPermissionEvaluator(permissionEvaluator);
		}
		RoleHierarchy roleHierarchy = getSingleBeanOrNull(RoleHierarchy.class);
		if (roleHierarchy != null) {
			this.defaultMethodExpressionHandler.setRoleHierarchy(roleHierarchy);
		}
		AuthenticationTrustResolver trustResolver = getSingleBeanOrNull(AuthenticationTrustResolver.class);
		if (trustResolver != null) {
			this.defaultMethodExpressionHandler.setTrustResolver(trustResolver);
		}
		GrantedAuthorityDefaults grantedAuthorityDefaults = getSingleBeanOrNull(GrantedAuthorityDefaults.class);
		if (grantedAuthorityDefaults != null) {
			this.defaultMethodExpressionHandler.setDefaultRolePrefix(grantedAuthorityDefaults.getRolePrefix());
		}

		this.defaultMethodExpressionHandler = this.objectPostProcessor.postProcess(this.defaultMethodExpressionHandler);
	}

}
```

```java title="PrePostMethodSecurityConfiguration.java"
final class PrePostMethodSecurityConfiguration {

	private static MethodSecurityExpressionHandler defaultExpressionHandler(
		ObjectProvider<GrantedAuthorityDefaults> defaultsProvider, ApplicationContext context) {
		DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler();
		defaultsProvider.ifAvailable((d) -> handler.setDefaultRolePrefix(d.getRolePrefix()));
		handler.setApplicationContext(context);
		return handler;
	}

}
```

### 参考

- [issue](https://github.com/spring-projects/spring-security/issues/12662)
- [pull request](https://github.com/spring-projects/spring-security/pull/12673)
- [GlobalMethodSecurityConfiguration.java ](https://github.com/spring-projects/spring-security/blob/6.0.x/config/src/main/java/org/springframework/security/config/annotation/method/configuration/GlobalMethodSecurityConfiguration.java)
- [PrePostMethodSecurityConfiguration.java](https://github.com/spring-projects/spring-security/blob/6.0.x/config/src/main/java/org/springframework/security/config/annotation/method/configuration/PrePostMethodSecurityConfiguration.java)

## 升级`spring-boot3`后使用Token请求保护资源报错

使用Token请求保护资源报错401

### 原因

这个问题的原因是`spring-security`中进行了重构需要对`securityContext`进行配置

### 解决方案

1. `http.securityContext().requireExplicitSave(false).and()`
2. `http.securityContext().securityContextRepository(new HttpSessionSecurityContextRepository()).and()`

### 备注

> spring6之后SecurityContextHolderFilter替换了SecurityContextPersistenceFilter<br/>
> SecurityContextRepository默认实现也变了<br/>
> (HttpSessionSecurityContextRepository) -> (RequestAttributeSecurityContextRepository)<br/>

### 参考

- [Spring Security 6 CustomAuthenticationFilter(intend to replace the UsernamePasswordAuthenticationFilter) does not work](https://stackoverflow.com/questions/74629234/spring-security-6-customauthenticationfilterintend-to-replace-the-usernamepassw)
- [Default to SecurityContextHolderFilter instead of SecurityContextPersistenceFilter #11110](https://github.com/spring-projects/spring-security/issues/11110)

## 升级`spring-boot3`后请求`/swagger-ui/index.html`报错

接口报错, 内容如下

```log title="chrome"
This page isn’t working
If the problem continues, contact the site owner.
HTTP ERROR 401
```

### 原因

springdoc版本过老, 需要升级到v2版本。<br/>
[springdoc.org](https://springdoc.org/)
上的有相关说明`For spring-boot v3 support, make sure you use springdoc-openapi v2`

本项目的原始配置如下

```xml title="pom.xml"

<dependency>
	<groupId>org.springdoc</groupId>
	<artifactId>springdoc-openapi-ui</artifactId>
	<version>1.6.14</version>
</dependency>
```

### 解决方案

升级springdoc版本到v2, 升级后的配置如下, v2的artifactId发生了变化

```xml title="pom.xml"

<dependency>
	<groupId>org.springdoc</groupId>
	<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
	<version>2.0.2</version>
</dependency>
```

### 参考

- [springdoc.org](https://springdoc.org/)
- [springdocv2](https://springdoc.org/v2/)
- [How to run Swagger 3 on Spring Boot 3](https://stackoverflow.com/questions/74614369/how-to-run-swagger-3-on-spring-boot-3)

### 代码调用流程

```log title="AuthorizationFilter.doFilter"
this.authorizationManager.check(this::getAuthentication, request);
```

```log title="ObservationAuthorizationManager.check"
AuthorizationDecision decision = this.delegate.check(wrapped, object);
```

```log title="RequestMatcherDelegatingAuthorizationManager.check"
matcher.matcher(request);
```

```log title="MvcRequestMatcher.matcher"
// 返回了`path`为`/error`的`handlerMapping`(说明没有找到对应的`handlerMapping`)
MatchableHandlerMapping mapping = getMapping(request);
```

```log title="RequestMatcherDelegatingAuthorizationManager.check"
RequestMatcher matcher = mapping.getRequestMatcher();
MatchResult matchResult = matcher.matcher(request);
// 由于swagger对应的handler找不到, 所以没有Match
if (matchResult.isMatch()) {
	AuthorizationManager<RequestAuthorizationContext> manager = mapping.getEntry();
	if (this.logger.isTraceEnabled()) {
		this.logger.trace(LogMessage.format("Checking authorization on %s using %s", request, manager));
	}
	// 后续命中了Mvc [pattern='/*/*.html']对应的Matcher, 而该Matcher对应的匹配规则要求需要`authentication`不为空, 导致报错
	return manager.check(authentication, new RequestAuthorizationContext(request, matchResult.getVariables()));
}
```