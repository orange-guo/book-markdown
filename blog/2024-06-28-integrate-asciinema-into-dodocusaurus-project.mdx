---
authors: [ xiangcheng.kuo ]
tags: [ docusaurus, react, mdx, asciinema, remark, mdast, mdast-util-mdx-jsx, mdast-util-mdxjs-esm, rehype-katex, remark-math ]
---

# 将Asciinema集成到Docusaurus项目中

当`Docusaurus`项目包含技术相关的文档时通常涉及到终端操作, 通常会通过`markdown`提供的`codeblock`语法来完成.<br/>
但是当终端操作比较复杂时(例如包含了大量输入输出), 会导致文档阅读困难.<br/>
为了提升阅读友好性, 需要有一个工具能够可视化终端操作, 最好能够展示操作的过程, 同时应该避免视频形式的展示(因为视频会占用很多空间, 此外终端操作的过程中全部为文本, 其并不会占用太多空间).

根据上述背景, 主要有以下几个问题

- `markdown`提供的内置的`codeblock`语法在涉及到复杂的终端操作时不够友好.
- 如果将终端操作录制为视频, 会占用很多空间, 终端操作的过程全部为文本, 其并不会占用太多空间, 这些空间我们可以节省.

<!--truncate-->

## Asciinema

[Asciinema](https://asciinema.org/)<br/>

是一个开源的终端录制工具, 可以将终端操作记录下来并生成一个可播放的终端动作文件, 生成的文件中只包含了文本信息, 不会占用太多空间, 很适合用来展示终端操作的演示.<br/>

要生成终端操作的演示, 需要安装其命令行工具, 并使用其命令行工具将终端操作录制下来.<br/>

参考[getting-started](https://docs.asciinema.org/getting-started/)中提供的相关介绍.<br/>


## 实现在Docusaurus集成Asciinema

我们应该尽量使用`markdown`提供的语法来完成终端操作文件的渲染.<br/>
如果能够按照以下语法进行引用, 并且在`markdown`渲染时将动画文件渲染到页面中, 那么对编写文档来说将会特别方便.<br/>

**语法:**

```md
[x](/blog/2024-06-28-demo.cast)
```

**效果:**

[x](/blog/2024-06-28-demo.cast)


不幸的是, `Asciinema`只提供了`Javascript`基本实现, 由于`Docusaurus`是基于`React`实现, 这意味着我们需要`React`实现, 同时也没有`Docusaurus`的集成实现.<br/>

要能够在`Docusaurus`中集成`Asciinema`, 我们需要完成以下几个功能.<br/>

- 将`Asciinema`提供的`Javascript`库封装为`Docusaurus`支持的`React`组件.
- 扩展`Docusaurus`的`Markdown`解析器, 使其支持将`Asciinema`动画文件转换为`React`组件.


## 封装`Asciinema`库为`React`组件

首先, 将`Asciinema`添加到项目中:

```bash
yarn add asciinema-player
```

接下来, 需要封装出`React`组件.

```ts title="src/components/asciinema/react/index.js"

// import 'asciinema-player/dist/bundle/asciinema-player.css';
import './asciinema-player.css'; // We hacked the CSS of the asciinema-player located at 'asciinema-player/dist/bundle/asciinema-player.css'.

import {FC, useEffect, useRef, useState} from 'react';
import {useColorMode} from '@docusaurus/theme-common';

type Props = {
	src: string;
	cols: string;
	rows: string;
	autoPlay: boolean
	preload: boolean;
	loop: boolean | number;
	startAt: number | string;
	speed: number;
	idleTimeLimit: number;
	theme: string;
	poster: string;
	fit: string;
	fontSize: string;
};

const AsciinemaPlayer: FC<Props> = ({src, ...rest}) => {
	const [player, setPlayer] = useState<typeof import ('asciinema-player')>()
	useEffect(() => {
		import("asciinema-player").then(p => {setPlayer(p)})
	}, []) // executed once

	const { colorMode } = useColorMode();
	const ref = useRef<HTMLDivElement>(null);

	useEffect(
		() => {
			const currentRef = ref.current

			const instance = player?.create(src, currentRef, {...rest, theme: colorMode === 'dark' ? 'docusaurus-classic-dark' : 'docusaurus-classic-light'});

			return () => {
				instance?.dispose()
			}
		}, [src, rest, colorMode, player] // executed every time the array items change
	);

	return <div ref={ref}/>;
};

export default AsciinemaPlayer;
```

[src/components/asciinema/react/asciinema-player.css](/blog/2024-06-28-asciinema-player.css)

上面的代码中, 我们将`Asciinema`的`Javascript`库封装为`React`组件.<br/>
通过`React`提供的`Ref`功能, 将`Asciinema`操作的`DOM`组件和`React`组件进行关联, 这样就可以确保`React`能够集成对应组件.<br/>
为了避免重复渲染, 需要确保组件被`dispose`.<br/>
为了能够适配`Docusaurus`的主题, 我们需要确保组件能够适应不同的主题, 为了完成这个工作, 我们需要引入自定义的`CSS`样式, 在`Asciinema`提供的基本样式基础上, 我们添加了对`Docusaurus`主题的支持.


## 自定义`Markdown`语法树解析

首先, 我们需要将下面的依赖安装到项目中:

```bash
yarn add rehype-katex remark-math
```

上面这两个库用作`Markdown`语法树解析, 并对语法树内容进行修改, 从而达到我们的目的.


编写以下代码实现

```ts title="src/components/asciinema/markdown/markdown.ts"
import {visit} from 'unist-util-visit';

const plugin = (options) => {
	const transformer = async (tree) => {
		let importInserted = false;

		visit(tree, 'link', (node, index, parent) => {
			if (!node.url.endsWith(".cast")) {
				return
			}

			if (!importInserted) {
				const importNode = {
					type: 'mdxjsEsm',
					value: `import AsciinemaPlayer from '@site/src/components/asciinema/react';`,
					data: {
						estree: {
							type: 'Program',
							body: [
								{
									type: 'ImportDeclaration',
									specifiers: [
										{
											type: 'ImportDefaultSpecifier',
											local: { type: 'Identifier', name: 'AsciinemaPlayer' }
										}
									],
									source: { type: 'Literal', value: '@site/src/components/asciinema/react' }
								}
							]
						}
					}
				};

				tree.children.unshift(importNode);
				importInserted = true;
			}

			const jsxNode = {
				type: 'mdxJsxFlowElement',
				name: 'AsciinemaPlayer',
				attributes: [
					{ type: 'mdxJsxAttribute', name: 'src', value: node.url },
					{ type: 'mdxJsxAttribute', name: 'theme', value: 'docusaurus-classic-light' },
					{ type: 'mdxJsxAttribute', name: 'rows', value: 30 },
					{ type: 'mdxJsxAttribute', name: 'idleTimeLimit', value: 3 },
					{ type: 'mdxJsxAttribute', name: 'preload', value: true }
				],
				children: []
			};

			parent.children.splice(index, 1, jsxNode);
		});
	};
	return transformer;
};

export default plugin;
```

在上述代码中, 我们对`link`进行了修改, 并将其转换为`Jsx`语法, 这样可以在`Markdown`中直接使用`Asciinema`组件.



## Docusaurus集成

参考以下配置配置`Docusaurus`:

```js title="docusaurus.config.js"
import rehypeKatex from 'rehype-katex';
import asciinema from './src/components/asciinema/markdown/markdown';

export default {
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          path: 'docs',
          beforeDefaultRemarkPlugins: [asciinema],
          rehypePlugins: [rehypeKatex],
        },
        blog: {
          beforeDefaultRemarkPlugins: [asciinema],
          rehypePlugins: [rehypeKatex],
       }
      },
    ],
  ],
};
```

上述配置将对`Docusaurus`中的`Docs`和`Blog`进行了配置, 并将`Markdown`中的`Asciinema`组件进行解析.

## 参考

- [MDX Plugins](https://docusaurus.io/docs/markdown-features/plugins)
- [remark](https://github.com/remarkjs/remark)
- [mdast](https://github.com/syntax-tree/mdast)
- [mdast-util-mdx-jsx](https://github.com/syntax-tree/mdast-util-mdx-jsx)
- [mdast-util-mdxjs-esm](https://github.com/syntax-tree/mdast-util-mdxjs-esm?tab=readme-ov-file#mdxjsesm)