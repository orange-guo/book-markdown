当一个对象已经没有用时, 记得要手动消除对象引用, 以避免内存泄露
##示例代码
```
// 创建一个Cache数组, 用于缓存对象
Object[] cache = new Object[16];

// 向缓存中插入对象, 现在缓存中只有一个对象
// 该对象目前被cache对象引用
// 只有当它不被引用, 才会被回收
cache[0] = new Object();

// 当不需要缓存这个对象时, 将该对象的引用关系断掉(设置成null)
cache[0] = null;
```
这样对象之间的关系被切除, 未被引用的孤儿对象被垃圾回收器标记两次后处理

如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。

这类问题的解决方法很简单：一旦对象引用过期，将它们设置为`null`。

一般来说，**当一个类自己管理内存时，应该警惕内存泄漏问题**。 每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。

**另一个常见的内存泄漏来源是缓存**。一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现了一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用`WeakHashMap`来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，`WeakHashMap`才有用。