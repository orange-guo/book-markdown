# 介绍

## 领域模型
### 领域的意思
在业务中的某个具体范围
### 领域的细节
- 领域对象
- 对象之间的交互
- 领域的语言
- 模型内的上下文
### 管理复杂度
#### 基本复杂度
领域问题本身固有的
### 模型的附带复杂度
实现业务解决方案时引入的附加复杂度
### 减少附带复杂度的数量
使用技术手段降低复杂度的数量(结构化模型)




## 领域驱动设计介绍
模型是问题领域到解决领域的直接映射
### 边界上下文
#### 什么是边界上下文
整个模型中的某个小模型
#### 减少边界上下文之间的交互
- 降低耦合
- 增加内聚
### 领域模型元素
#### 实体
- 拥有不变的身份标识
- 语义上的可变
- 在生命周期里传递多种状态
- 在业务中通常拥有明确的生命周期
- 使用不可变数据结构构建实体(可变性在面对并发操作时会出现问题)
#### 值对象
- 不可变
- 语义上的不可变
- 能在实体间自由共享
#### 领域服务
- 实现不同领域元素之间行为交互
- 相对于实体和值对象更高级别的抽象
- 涵盖多个实体和值对象
- 通常对一个业务的用例进行建模
#### 领域元素的类型取决与边界上下文




## 领域对象的生命周期
### 领域对象的生命周期事件
- 创建
- 参与行为
- 持久化
### 工厂
使用工厂抽象处理其生命周期的创建部分<br/>
好处: 
1. 所有创建的代码保存在一个地方
2. 抽象了调用者创建实体的过程
### 聚合
- 由一个或多个实体, 值对象以及原始属性(primitive attribute)组成
- 边界上下文里的聚合也通常被看作模型中的执行边界
聚合根的目标:<br/>
1. 确保聚合内部业务规则与执行的边界上下文保持一致
2. 防止聚合的实现泄漏给客户端
### 仓储
- 在持久化存储中操作实体的接口
- 不会暴露底层关系型数据模型
### 通用语言
与业务术语强相关的词语命名



## 函数化思想
### 不可变性
### 可变状态的问题
- 意味着对象的状态可以被对象的多个引用更新
- 在推到代码时是一个反模式
### 不可变设计
将尸体改造为不可变的抽象
### 设计函数式领域模型的原则
- 将不可变状态建模为代数数据类型(algebraic data type,ADT)
- 在模块中将行为建模为函数(将状态从行为中分离)
- 模块里的行为对ADT中的类型起作用
- ADT的定义不包含任何行为
- 隔离纯函数
## 纯函数组合
将不同部分捆绑在一起形成一个整体



## 管理副作用
### 什么是副作用
函数对外部产生了影响(打印,异常,等)
### 管理副作用
尽可能将副作用与纯领域逻辑剥离开

## 纯模型元素的优点



## 响应式领域模型
### 为什么需要良好的响应性
良好的用户体验
### 响应式模型的基本特征
- 弹性(面对失败)
- 伸缩性(面对过高的负载能够改善系统服务)
- 消息驱动(服务之间松耦合)
上面



## 事件驱动编程
### 事件与命令
## 总结
- 模型内避免可变的状态
- 引用透明
- 有机增长
- 聚焦在核心领域
- 函数使响应更容易
- 针对失败的设计
- 用基于事件的建模来补充函数式模型